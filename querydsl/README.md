# Querydsl

### 단축키

- 환경설정 : Command + ,
- 다른 모든 창 숨기기 : Command + Shift + F12
- 프로젝트 사이드 바 보이기 : Command + 1
- 파라미터 정보 : Command + P
- 코드 정의 위치 변경 : Shift + Command + 방향키 위, 아래
- 정의 또는 사용하는 곳으로 이동 : Command + B
- 구현체로 이동 : Option + Command + B

### 애노테이션

- @Commit
  - 테스트 환경에서 사용하면 다른 테스트와 꼬일 수 있다.
- @Profile
  - application 설정 파일의 active 의 값을 지정하면 그에 따라 설정 파일이 달라진다.
- @QuerydslPredicate
  - join 이 안돼서 한계가 있다.
  - 실무에서 사용하지 않는 것을 권장한다.

### QueryDSL

- JPQL 의 빌더 역할이다.

### Q-Type

- new QMember("m1")
- "m1"으로 alias select 검색이 된다.
- 같은 테이블을 join 해야 할 경우 alias 가 같으면 안되니 new 키워드로 사용해야 한다. 그렇지 않을 경우 사용할 일이 없다.

### 검색조건

- startsWith 는 성능 관련해서 사용한다.

### 페이징

- offset : 스킵할 개수

### 조인

- 연관 관계가 없어도 조인이 가능하다. (세타 조인)
- 세타 조인

  - from 절에 엔티티를 나열하면 된다.
  - 모든 회원, 모든 팀 엔티티를 조인(카티션 프로덕트)하고 where 절에서 필터링 한다. DB 마다 성능 최적화를 한다.
  - 외부 조인 (left outer, right outer) 불가능
  - 조인 on 절 사용하면 외부 조인 가능

- on 절
  - 조인 대상 필터링 또는 연관관계가 없는 엔티티 외부조인을 할 때 사용한다.
  - 주로 연관관계가 없는 엔티티 외부조인할 때 많이 사용한다.
  - on 절을 활용해 조인 대상을 필터링 할 때, 외부조인이 아니라 내부조인(inner join)을 사용하면,
    where 절에서 필터링 하는 것과 기능이 동일하다. 따라서 on 절을 활용한 조인 대상 필터링을 사용할 때,
    내부조인 이면 익숙한 where 절로 해결하고, 정말 외부조인이 필요한 경우에만 이 기능을 사용하자.

### 서브쿼리

- JPA JPQL에서 select, where 절의 서브쿼리는 가능하다. from 절의 서브쿼리(인라인 뷰)는 안된다.
- 당연히 Querydsl 도 지원하지 않는다.
- from 절을 쓰는 이유는 안좋은 이유가 많다. 화면에 맞춰서 쿼리를 복잡하게 짜면 from 절을 계속 중첩해서 작성하는 경우가 있다.
- DB에서는 데이터를 필터링해서 가져오는 역할만하고 로직들은 애플리케이션이나 프레젠테이션에서 끝내는면 from 절 서브쿼리를 줄일 수 있다.
- 실시간 트래픽이 중요하면 쿼리가 중요해서 화면에 중요한 부분을 캐시해서 처리한다. 근데 어드민 페이지라면 복잡하게 쿼리를 작성하는 것 보다 쿼리를 두번 세번 나눠서 실행하는 게 훨씬 나을 수도 있다.

- from 절의 서브쿼리 해결방안
  - 서브쿼리를 join으로 변경한다. (가능한 상황도 있고, 불가능한 상황도 있다.)
  - 애플리케이션에서 쿼리를 2번 분리해서 실행한다.
  - nativeSQL을 사용한다.

### Case 문

- Case 문은 잘 사용하지 않는다.
- 상황에 따라서 쓰일 수도 있다.
- DB는 로우 데이터를 최소한의 필터링과 그룹핑을 해서 데이터를 줄이는 일을 하고 실제로 "열살", "스무살" 형태로 보여주는 것은 DB에서 처리하지 않고
  애플리케이션이나 프레젠테이션 계층에서 바꿔주는 것이 좋다.

### stringValue()

- 문자가 아닌 타입들을 변환할 수 있다.
- enum 타입 때문에 값이 안나오는 경우가 있는데 그럴 때 사용하면 된다.

### com.querydsl.Tuple

- 리파지토리 계층에서 사용하는 것은 괜찮은데, 서비스 계층이나 컨트롤러까지 넘어가는 것은 좋은 설계가 아니다.
- JPA 나 Querydsl 기술을 쓴다는 것을 핵심 비즈니스 로직이나 서비스 계층에서 안다는 것은 좋지 않다.
- Jdbc 를 쓸 때 반환해주는 ResultSet 을 리파지토리나 DAO 객체 안에서만 사용하고 나머지 계층에서는 의존을 없게 하는게 좋은 설계다.
  그래야 하부 기술을 Querydsl 에서 다른 걸로 바꾸더라도 서비스나 컨트롤러를 바꿀 필요가 없다.
  보통 스프링이 이런 방식으로 설계하도록 유도한다.
- Tuple 을 바깥 계층에서 사용하는 것 보다는 DTO 로 변환해서 사용하는 것을 권장한다.

### Projections.bean()

- setter 로 DTO 에 데이터 인젝션

### Projections.constructor()

- 컴파일 시점에 에러가 찾지 못한다.
- 런타임 시점에 에러가 발생한다.

### ExpressionUtils.as()

- 메서드의 두번째 파라미터로 alias 를 할 수 있다.
- 서브쿼리에 이름이 없는 경우 별칭을 주기 위해서 사용한다. 서브쿼리인 경우에는 별칭을 줄 수 있는 다른 방법이 없다.
- 자주 사용하지는 않는다.

### @QueryProjection

- 생성자에 붙이면 해당 클래스도 Q 타입 파일이 생성된다.
- Projections.constructor() 을 사용한 방법과 다르게 컴파일 시점에 에러를 찾아준다.
- 단점
  - Q 타입 파일을 생성해야 한다.
  - DTO 가 Querydsl 의 의존성을 가지게 된다.
  - DTO 는 여러 레이어에서 사용할 수 있는데 의존성을 가지게 되어 순수하지 않게 된다. 그래서 아키텍쳐 측면에서 좋지 않을 수 있다.

### 동적 쿼리

- BooleanBuilder
  - 초깃값 지정가능
  - and, or 등 사용가능
  - 빌더를 생성하는 searchMember1 메서드에는 앞에서 조건 처리하는 로직이 수행되고 나서 쿼리 실행 로직이 나온다. 이런 설계는 좋다고 볼 수 없다.
  - searchMember2 메서드는 조건 처리 로직을 별도의 메서드로 분리해서 쿼리 실행 로직을 바로 확인할 수 있다. 이런 설계가 더 좋은 방법이다.
- Where 다중 파라미터

  - 실무에서 많이 사용
  - 기존 XML 이나 Mybatis 에서는 사용할 수 없던 방식이다.
  - 자바 코드라서 컴포지션이 가능하다. 합성을 해서 로직을 처리한다.
  - 메소드로 만들어서 다른 로직에서 재사용을 할 수 있고 빌더에서도 재사용 할 수 있다.
  - 가독성이 높아진다.
  - where 조건의 null 은 무시된다.
  - select 프로젝션이 바뀌어도 where 절에서 파라미터로 넘겨준 메서드를 재사용할 수 있다.
  - Builder 를 써야하는 경우가 생기지 않는다면 기본적으로 Where 다중 파라미터로 동적 쿼리를 작성하는 것을 권장한다.

- BooleanExpression

  - 빌더 사용으로 조립이 가능하다.
  - Predicate 를 구현하고 있다.
  - 기본 반환 타입인 Predicate 대신 사용하면 빌더를 사용할 수 있다.

- 벌크 연산
  - add : 더하기, 빼기는 -1 을 add 하면 된다.
  - multiply : 곱하기
    - 실무에서 많이 사용한다.

### SQL function

- 직접 함수를 만들어서 사용하는 방법이 있다. JPA 기본편 참고
- Querydsl 에서 안시 표준 함수는 기본적으로 내장하고 있다.

### JPAQueryFactory

- Querydsl 을 사용하려면 필요하다.
- 생성자에서 생성해도 되고, Bean 으로 등록해서 주입 받아도 된다.

### 동시성

- @Bean 으로 등록한 객체는 멀티 쓰레드에서도 동시성 문제가 없다.
- JPAQueryFactory 의 동시성 문제는 EntityManager 에 의존한다.
  EntityManager 는 스프링하고 같이 쓰면 동시성 문제와 관계없이 트랜잭션 단위로 분리되서 동작하게 된다.
  필드에 선언되어 자동으로 주입 받는 EntityManager 는 진짜 영속성 컨텍스트의 EntityManager 가 아니고 프록시인 가짜를 주입해준다.
  그럼 그 프록시가 트랜잭션 단위로 전부 다른 곳에 바인딩 되도록 라우팅 해준다.
  결론은 멀티 쓰레드 환경에서 동시성 문제는 걱정하지 않아도 된다.

### 동적쿼리

- 주의사항
  - 조건이 모두 null 이라면 모든 데이터틑 join 해서 가져오게 된다. 이러면 성능상 문제가 있어서 조건이 하나라도 있는게 좋거나 데이터 가져오는 개수를 리미트하는게 좋다.

### JpaRepository 구현

- JpaRepository 를 상속하는 MemberRepository 인터페이스를 구현하는 구현체의 파일명의 규칙은 " MemberRepository + Impl" 가 되어야 한다.

### 조회 (select)

- 특정한 기능에 정해진 조회라면 JpaRepository 를 상속하고, 구현체의 커스텀 인터페이스를 만들지 않고
  다른 인터페이스를 상속하지 않는 별도의 리파지토리에 특정 기능 로직을 분리시킨다.
  굳이 모든 기능을 커스텀에 맞추는 것은 좋은 설계는 아니다.
  공용으로 재사용성의 가능성이 있으면 순수한 리파지토리를 만들고,
  공용으로 사용하지 않고 특정 API 에 종속적이라면 그 API 의 수정 라이프사이클은 화면에 맞춰서 기능이 변경되기 때문에 분리해서 만들면 찾기 편하고 관리하는 유지보수 측면에서도 더 좋다.
- 기본적으로는 Custom 으로 개발하고 프로젝트가 커지고 아키텍쳐적으로 유연하게 개발하고 싶으면 특정 API 에 종속적인 리파지토리를 분리하는 것도 좋다.

### Pageable

- 스프링 데이터 Pageable 은 기본적으로 offset 이나 전체 페이지 수를 알 수 있다.

### fetchResults()

- Deprecated 되었으므로 searchPageSimple 를 사용하지 않아야 한다.

### 컨텐츠, 카운트 쿼리

- 컨텐츠 쿼리는 복잡한데 카운트 쿼리는 되게 쉽게 만들 수 있을 때가 있다. deprecatedSearchPageSimple 처럼 한번에 쿼리를 가져오면 최적화를 하지 못한다.
  최적화를 하려면 컨텐츠, 카운트 쿼리를 분리해야 실행해야 한다.
  - 예를 들어서 카운트 쿼리를 실행했는데 데이터가 없으면 컨텐츠 쿼리를 실행시키지 않는걸로 최적화 할 수가 있다.
  - 큰 프로젝트라면 카운트 쿼리를 최적화할 수 있으면 최적화 하는 것이 좋다.
  - 작은 프로젝트라면 카운트 쿼리를 최적화하는 것은 의미가 없을 확률이 높다.

### PageableExecutionUtils.getPage()

- content 와 pageable 의 totalSize 를 보고 페이지 시작이면서 컨텐츠 사이즈가 페이지 사이즈보다 작거나,
  마지막 페이지 일 때 (offset + 컨텐츠 사이즈를 더해서 전체 사이즈 구함) 세 번째 파라미터의 함수를 호출하지 않는다.
- 예를 들어서 첫번째 페이지에서 전체 데이터가 100개 이고 한 페이지당 보여줄 사이즈를 200개로 하면 처음에 데이터를 모두 불러왔기 때문에 카운트 쿼리가 실행되지 않는다.

### Pageable

- 컨트롤러에서 Pageable 인터페이스를 넘기면 컨트롤러가 바인딩 될 때, 스프링 데이터가 전부 바인딩 해준다.

### 스프링 데이터 정렬

- 스프링 데이터를 사용하면 검색 조건에 정렬을 할 수 있다.
- 스프링 데이터 정렬을 Querydsl 에 맞춰서 쓰기가 어렵다.
- 자동화하는게 어렵고 수동화는 직접할 수 있다.
- 단순하면 조인에서 가능하지만 복잡해지면 하면 동작하지 않는다.
- 복잡해지면 직접 파라미터로 받아서 order 조건을 넣는 것을 권장한다.
- 루트 엔티티 범위를 넘어가는 동적 정렬 기능이 필요하면 스프링 데이터 페이징이 제공하는 Sort 보다는 파라미터를 받아서 처리하는 것을 권장한다.

### QuerydslPredicateExecutor

- 이 인터페이스를 상속하면 Querydsl predicate 조건을 넣을 수 있다.
- 한계가 명확하다. 이런 기술을 쓸 때는 실무에서 쓸 수 있는지 판단해야 한다. RDB 를 사용하기 때문에 join 을 피할 수 없다.
- 한계
  - 조인 X (묵시적 조인은 가능하지만 left join이 불가능하다.)
  - 클라이언트가 Querydsl 에 의존해야 한다. Querydsl 이 아닌 다른 구체화 기술로 바꾸면 비용이 많이 들고 프로젝트가 복잡해지면 이 기술을 사용하기 어려워진다. 서비스나 컨트롤러 클래스 등 다른 계층에서 Querydsl 이라는 구현 기술에 의존해야 한다. 복잡한 실무환경에서 사용하기에는 한계가 명확하다.
  - DTO 처럼 파라미터에 순수한 자바 POJO 를 넘기는데, Querydsl 객체를 만들어서 넘겨야 한다.
  - 테이블이 하나라면 사용하는데 문제는 없지만 실무에서는 사용하지 않는 것을 권장한다.
- 참고: QuerydslPredicateExecutor 는 Pagable, Sort를 모두 지원하고 정상 동작한다.

### Repository

- Repository 를 만드는 이유는 리파지토리를 만들고 하부에 Querydsl 같은 구체화 된 기술을 숨겨야 한다. 그래야 Querydsl 이 아닌 다른 기술로 교체할 수 있다.

### QuerydslRepositorySupport

- Querydsl 라이브러리를 사용하기 위해서 리파지토리 구현체를 편리하게 해준다.
- 내부저으로 EntityManager, Querydsl 유틸리티 객체를 제공한다.
- Querydsl
- 쉽게 Querydsl JPA query API 에 액세스하는 헬퍼 객체이다.

### getQuerydsl().applyPagination()

- 실무에서 사용한다. 페이징 문제가 아니면 사용해도 된다.

- 장점
  - getQuerydsl().applyPagination() 스프링 데이터가 제공하는 페이징을 Querydsl로 편리하게 변환 가능 (단! Sort는 오류발생)
  - from() 으로 시작 가능(최근에는 QueryFactory를 사용해서 select() 로 시작하는 것이 더 명시적) EntityManager 제공
  - offset ,limit 를 자동으로 설정해준다.
- 한계
  - Querydsl 3.x 버전을 대상으로 만듬
  - Querydsl 4.x에 나온 JPAQueryFactory로 시작할 수 없음
  - select로 시작할 수 없음 (from으로 시작해야함) QueryFactory 를 제공하지 않음
  - 스프링 데이터 Sort 기능이 정상 동작하지 않음
  - Sort 조건이 넘어오면 일반 Sort 는 안되고 QSort 는 된다. 파라미터 바인딩 Sort 는 안된다.
  - 스프링 데이터를 쓸 때, 클라이언트에서 Pageable 를 파라미터 바인딩으로 받아오고 Sort 조건을 받으면 Sort 는 동작하지 않는다.
  - 사용한다면 Querydsl 의 Sort 는 직접 작성해야 한다.
